package org.example.TBFV;

import org.example.finder.CrashCondition;

import java.util.*;

import static org.example.TBFV.ExecutionEnabler.*;
import static org.example.TBFV.ExecutionPathPrinter.addPrintStmt;

public class Verifier {

    public TDResult validateATAndD(String ssmp, String T, CrashCondition cc, int maxRoundsOf1CoupleOfTD, List<Testcase> historyTestcases,Set<String> prePathConstrains) throws Exception {
        int countOfPathValidated = 0;
        TBFVResult r = null;
        String currentTD = "T: " + T + "\t" + "D: " + cc.getD();
        long startTime = System.currentTimeMillis();
        System.out.println("startTime: " + startTime);
        long timeoutMs = 1000000;
        while(countOfPathValidated < maxRoundsOf1CoupleOfTD){

            String testCase = generateMainMdUnderExpr(T,prePathConstrains,ssmp);
            if(testCase == null || testCase.isEmpty()){
                System.out.println("No testcase generated by generateMainMdUnderExpr function, " +
                        "the current T is: " + T + ", " +
                        "the current prePathConstrains are: " + prePathConstrains);
                return new TDResult(TDValidationStatus.TESTCASE_GENERATION_FAILED);
            }
            Testcase currentTC = new Testcase(testCase);
            historyTestcases.add(currentTC);

            if(testCase == null || testCase.isEmpty() || testCase.startsWith("ERROR")){
                return new TDResult(TDValidationStatus.TESTCASE_GENERATION_FAILED,
                        "current TD:" + currentTD + "，generate testcase failed, please check the log for details!", "");
            }

            //validate a path, a path is expressed by T and prePathConstrains
            long recordPathVerifiedStartTime = System.currentTimeMillis();
            r = validate1Path(ssmp,testCase,prePathConstrains,T,cc);
            long pathVerifyElapsed = System.currentTimeMillis() - recordPathVerifiedStartTime;
            currentTC.setTimeCostInMs(pathVerifyElapsed);
            System.out.println("pathVerifyElapsed: " + pathVerifyElapsed);
            if(r == null){
                String pathInfo = "T: " + T + "\t" + "D: " + cc.getD() + "\n" + "testcase: " + testCase + "\n" + "prePathConstrains: " + prePathConstrains;
                return TDResult.createUnexpectedErrorResult("No result returned while validating path : " + pathInfo);
            }

            String currentCt = r.getPathConstrain();
            prePathConstrains.add(currentCt);
            //record the ct of the current path
            currentTC.setLogicExprOfPath(currentCt);
            currentTC.setLogicExprOfDT(r.getDt());

            long elapsed = System.currentTimeMillis() - startTime;
            if (elapsed > timeoutMs) {
                r.setStatus(-99);
                Testcase timeoutTc = new Testcase("Timeout here!");
                timeoutTc.setLogicExprOfDT("Path Verification TIMEOUT!");
                timeoutTc.setLogicExprOfPath("Path Verification TIMEOUT!!");
                historyTestcases.add(timeoutTc);
                break;
            }

            //no solutions, and no other paths to be validated
            if(r.getStatus() == 3){
                return TDResult.createSuccessResult();
            }

            //There are no solutions under this path, but there are still other paths to be validated
            if(r.getStatus() == 0){
                currentTC.setDangerousInput(false);
                countOfPathValidated++;
                continue;
            }

            //if the solver gives a solution, that means there will be a runtime error when the params are assigned as the solution
            //in this case, we need to collect this kind of dangerous inputs
            if(r.getStatus() == 2 || r.getStatus() == 4){
                List<Testcase> dangerousTcsInThisPath = getAllDangerousTcsFromResult(r.getCounterExample(),currentCt,r.getDt());
                if(dangerousTcsInThisPath.isEmpty()){
                    return TDResult.createUnexpectedErrorResult("There should be some tcs but it disappeared unexpectedly!");
                }
                historyTestcases.addAll(dangerousTcsInThisPath);
                return TDResult.createCounterExampleResult("runtime error could happend","");
//                if(r.getStatus() == 2){
//                    countOfPathValidated++;
////                    continue;
//                }
//                break;
            }
            break;
        }

        if(r.getStatus() == -3){
            System.out.println("Timeout error occurred during validation of " + currentTD);
            return TDResult.createTimeoutResult("Timeout error occurred during validation of " + currentTD, T, cc.getD());
        }
        if(r.getStatus() == -2){
            return TDResult.createUnexpectedExceptionResult("Unexpected exception thrown by the program under T: " + T + "\n Error info :" + r.getCounterExample());
        }
        if(r.getStatus() == -1){
            if(r.getCounterExample().contains("Unknown variable")){
                return TDResult.createUnknownVariableResult(r.getCounterExample());
            }
            return TDResult.createUnexpectedErrorResult("Unknown error occurred during validation of " + currentTD);
        }
        if(r.getStatus() == 0 && countOfPathValidated == maxRoundsOf1CoupleOfTD){
            return TDResult.createPartiallySuccessResult();
        }
        if(r.getStatus() == 1){
            return TDResult.createUnexpectedErrorResult("Unknown error occurred during validation of " + currentTD);
        }
        if(r.getStatus() == -99){
            return TDResult.createTimeoutResult("Timeout error occurred during validation of " + currentTD, T, cc.getD());
        }
        return TDResult.createUnexpectedErrorResult("Unknown error occurred during validation of " + currentTD);
    }

    public TDResult validateATAndDByCSC(String ssmp, String T, CrashCondition cc, List<Testcase> historyTestcases) throws Exception {
        TBFVResult r = null;
        String currentTD = "T: " + T + "\t" + "D: " + cc.getD();
        Set<String> prePathConstrains = new HashSet<>();
        long startTime = System.currentTimeMillis();
        long timeoutMs = 10000000;
        while(true){
            String testCase = generateMainMdByCSC(ssmp);
            System.out.println("TestCase generated by CSC: " + testCase);

            if(testCase.equals("CSC_OK")){
                return new TDResult(TDValidationStatus.SUCCESS,"CSC SUCCESS");
            }
            if(testCase.equals("CSC_UNFEASIBLE")){
                continue;
            }

            Testcase currentTC = new Testcase(testCase);
            historyTestcases.add(currentTC);

            if(testCase == null || testCase.isEmpty() || testCase.startsWith("ERROR")){
                return new TDResult(TDValidationStatus.TESTCASE_GENERATION_FAILED,
                        "current TD:" + currentTD + "，generate testcase failed, please check the log for details!", "");
            }

            //validate a path, a path is expressed by T and prePathConstrains
            r = validate1Path(ssmp,testCase,prePathConstrains,T,cc);


            if(r == null){
                String pathInfo = "T: " + T + "\t" + "D: " + cc.getD() + "\n" + "testcase: " + testCase + "\n" + "prePathConstrains: " + prePathConstrains;
                return TDResult.createUnexpectedErrorResult("No result returned while validating path : " + pathInfo);
            }

            String currentCt = r.getPathConstrain();
            prePathConstrains.add(currentCt);
            //record the ct of the current path
            currentTC.setLogicExprOfPath(currentCt);
            currentTC.setLogicExprOfDT(r.getDt());

            long elapsed = System.currentTimeMillis() - startTime;
            if (elapsed > timeoutMs) {
                r.setStatus(-99);
                Testcase timeoutTc = new Testcase("Timeout here!");
                timeoutTc.setLogicExprOfDT("Path Verification TIMEOUT!");
                timeoutTc.setLogicExprOfPath("Path Verification TIMEOUT!!");
                historyTestcases.add(timeoutTc);
                break;
            }

            //no solutions, and no other paths to be validated
            if(r.getStatus() == 3){
                return TDResult.createSuccessResult();
            }

            //There are no solutions under this path, but there are still other paths to be validated
            if(r.getStatus() == 0){
                currentTC.setDangerousInput(false);
                continue;
            }

            //if the solver gives a solution, that means there will be a runtime error when the params are assigned as the solution
            //in this case, we need to collect this kind of dangerous inputs
            if(r.getStatus() == 2 || r.getStatus() == 4){
                List<Testcase> dangerousTcsInThisPath = getAllDangerousTcsFromResult(r.getCounterExample(),currentCt,r.getDt());
                if(dangerousTcsInThisPath.isEmpty()){
                    return TDResult.createUnexpectedErrorResult("There should be some tcs but it disappeared unexpectedly!");
                }
                historyTestcases.addAll(dangerousTcsInThisPath);
                if(r.getStatus() == 2){
                    continue;
                }
                break;
            }
            break;
        }

        if(r.getStatus() == -3){
            System.out.println("Timeout error occurred during validation of " + currentTD);
            return TDResult.createTimeoutResult("Timeout error occurred during validation of " + currentTD, T, cc.getD());
        }
        if(r.getStatus() == -2){
            return TDResult.createUnexpectedExceptionResult("Unexpected exception thrown by the program under T: " + T + "\n Error info :" + r.getCounterExample());
        }
        if(r.getStatus() == -1){
            if(r.getCounterExample().contains("Unknown variable")){
                return TDResult.createUnknownVariableResult(r.getCounterExample());
            }
            return TDResult.createUnexpectedErrorResult("Unknown error occurred during validation of " + currentTD);
        }
        if(r.getStatus() == 1){
            return TDResult.createUnexpectedErrorResult("Unknown error occurred during validation of " + currentTD);
        }
        if(r.getStatus() == -99){
            return TDResult.createTimeoutResult("Timeout error occurred during validation of " + currentTD, T, cc.getD());
        }
        return TDResult.createUnexpectedErrorResult("Unknown error occurred during validation of " + currentTD);
    }

    private List<Testcase> getAllDangerousTcsFromResult(String tcs,String currentPath,String dt){
        String[] split = tcs.split(";");
        List<Testcase> dangerousTcs = new ArrayList<>();
        for(String tcStr : split){
            Testcase tc = null;
            HashMap<String,String> map = new HashMap<>();
            String[] var_values = tcStr.split("&&");
            for(String v_v : var_values){
               String var = v_v.split("==")[0];
               String value = v_v.split("==")[1];
               map.put(var,value);
               tc = new Testcase(map);
               tc.setDangerousInput(true);
               tc.setLogicExprOfPath(currentPath);
               tc.setLogicExprOfDT(dt);
            }
            if(tc != null){
                dangerousTcs.add(tc);
            }
        }
        return dangerousTcs;
    }

    private TBFVResult validate1Path(String ssmp, String mainMd, Set<String> prePathConstrains, String T, CrashCondition cc) throws Exception {
        String addedPrintProgram = addPrintStmt(ssmp);
        String runnableProgram = insertMainMdInSSMP(addedPrintProgram, mainMd);
        System.out.println("runnableProgram: " + runnableProgram);
        List<String> prePathConstrainsList = new ArrayList<>(prePathConstrains);
        SpecUnit su = new SpecUnit(runnableProgram,T,cc.getD(),prePathConstrainsList);
        Map<String, String> varsMap = cc.getVarsMap();
        varsMap.forEach(su::addTmpVarType);
        //About TMPVAR
        System.out.println(su.toJson());
        TBFVResult r = Z3Solver.callZ3Solver(su);
        System.out.println("verification result: " + r);
        return r;
    }

}
